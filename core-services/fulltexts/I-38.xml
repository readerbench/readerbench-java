<?xml version="1.0" encoding="UTF-8"?>
<document language="en">
<meta>
<genre/>
<title>I-38</title>
<authors/>
<date>10-06-2017</date>
<source/>
<complexity_level/>
<uri/>
</meta>
<body>
<p id="0">Both the research and practice of combinatorial auctions have grown rapidly in the past ten years. In a combinatorial auction bidders can place bids on combinations of items, called packages or bidsets, rather than just individual items. Once the bidders place their bids, it is necessary to find the allocation of items to bidders that maximizes the auctioneer"s revenue. This problem, known as the winner determination problem, is a combinatorial optimization problem and is NP-Hard [10]. Nevertheless, several algorithms that have a satisfactory performance for problem sizes and structures occurring in practice have been developed. The practical applications of combinatorial auctions include: allocation of airport takeoff and landing time slots, procurement of freight transportation services, procurement of public transport services, and industrial procurement [2].</p>
<p id="1">Because of their wide applicability, one cannot hope for a general-purpose winner determination algorithm that can efficiently solve every instance of the problem. Thus, several approaches and algorithms have been proposed to address the winner determination problem. However, most of the existing winner determination algorithms for combinatorial auctions are centralized, meaning that they require all agents to send their bids to a centralized auctioneer who then determines the winners. Examples of these algorithms are CASS [3], Bidtree [11] and CABOB [12]. We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer.</p>
<p id="2">The PAUSE (Progressive Adaptive User Selection Environment) auction [4, 5] is one of a few efforts to distribute the problem of winner determination amongst the bidders.</p>
<p id="3">PAUSE establishes the rules the participants have to adhere to so that the work is distributed amongst them. However, it is not concerned with how the bidders determine what they should bid.</p>
<p id="4">In this paper we present two algorithms, pausebid and cachedpausebid, which enable agents in a PAUSE auction to find the bidset that maximizes their utility. Our algorithms implement a myopic utility maximizing strategy and are guaranteed to find the bidset that maximizes the agent"s utility given the outstanding best bids at a given time. pausebid performs a branch and bound search completely from scratch every time that it is called. cachedpausebid is a caching-based algorithm which explores fewer nodes, since it caches some solutions. 694 978-81-904262-7-5 (RPS) c 2007 IFAAMAS</p>
<p id="5">A PAUSE auction for m items has m stages. Stage 1 consists of having simultaneous ascending price open-cry auctions and during this stage the bidders can only place bids on individual items. At the end of this state we will know what the highest bid for each individual item is and who placed that bid. Each successive stage k = 2, 3, . . . , m consists of an ascending price auction where the bidders must submit bidsets that cover all items but each one of the bids must be for k items or less. The bidders are allowed to use bids that other agents have placed in previous rounds when building their bidsets, thus allowing them to find better solutions.</p>
<p id="6">Also, any new bidset has to have a sum of bid prices which is bigger than that of the currently winning bidset. At the end of each stage k all agents know the best bid for every subset of size k or less. Also, at any point in time after stage</p>
<p id="7">monotonically as new bidsets are submitted. Since in the final round all agents consider all possible bidsets, we know that the final winning bidset will be one such that no agent can propose a better bidset. Note, however, that this bidset is not guaranteed to be the one that maximizes revenue since we are using an ascending price auction so the winning bid for each set will be only slightly bigger than the second highest bid for the particular set of items. That is, the final prices will not be the same as the prices in a traditional combinatorial auction where all the bidders bid their true valuation. However, there remains the open question of whether the final distribution of items to bidders found in a PAUSE auction is the same as the revenue maximizing solution. Our test results provide an answer to this question.</p>
<p id="8">The PAUSE auction makes the job of the auctioneer very easy. All it has to do is to make sure that each new bidset has a revenue bigger than the current winning bidset, as well as make sure that every bid in an agent"s bidset that is not his does indeed correspond to some other agents" previous bid. The computational problem shifts from one of winner determination to one of bid generation. Each agent must search over the space of all bidsets which contain at least one of its bids. The search is made easier by the fact that the agent needs to consider only the current best bids and only wants bidsets where its own utility is higher than in the current winning bidset. Each agent also has a clear incentive for performing this computation, namely, its utility only increases with each bidset it proposes (of course, it might decrease with the bidsets that others propose).</p>
<p id="9">Finally, the PAUSE auction has been shown to be envy-free in that at the conclusion of the auction no bidder would prefer to exchange his allocation with that of any other bidder [2].</p>
<p id="10">We can even envision completely eliminating the auctioneer and, instead, have every agent perform the task of the auctioneer. That is, all bids are broadcast and when an agent receives a bid from another agent it updates the set of best bids and determines if the new bid is indeed better than the current winning bid. The agents would have an incentive to perform their computation as it will increase their expected utility. Also, any lies about other agents" bids are easily found out by keeping track of the bids sent out by every agent (the set of best bids). Namely, the only one that can increase an agent"s bid value is the agent itself.</p>
<p id="11">Anyone claiming a higher value for some other agent is lying.</p>
<p id="12">The only thing missing is an algorithm that calculates the utility-maximizing bidset for each agent.</p>
<p id="13">A bid b is composed of three elements bitems (the set of items the bid is over), bagent (the agent that placed the bid), and bvalue (the value or price of the bid). The agents maintain a set B of the current best bids, one for each set of items of size ≤ k, where k is the current stage. At any point in the auction, after the first round, there will also be a set W ⊆ B of currently winning bids. This is the set of bids that covers all the items and currently maximizes the revenue, where the revenue of W is given by r(W) = b∈W bvalue . (1) Agent i"s value function is given by vi(S) ∈ where S is a set of items. Given an agent"s value function and the current winning bidset W we can calculate the agent"s utility from W as ui(W) = b∈W | bagent=i vi(bitems ) − bvalue . (2) That is, the agent"s utility for a bidset W is the value it receives for the items it wins in W minus the price it must pay for those items. If the agent is not winning any items then its utility is zero.</p>
<p id="14">The goal of the bidding agents in the PAUSE auction is to maximize their utility, subject to the constraint that their next set of bids must have a total revenue that is at least bigger than the current revenue, where is the smallest increment allowed in the auction. Formally, given that W is the current winning bidset, agent i must find a g∗ i such that r(g∗ i ) ≥ r(W) + and g∗ i = arg max g⊆2B ui(g), (3) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue &gt; B(bitems ) and size(bitems ) ≤ k), and where B(items) is the value of the bid in B for the set items (if there is no bid for those items it returns zero). That is, each bid b in g must satisfy at least one of the two following conditions. 1) b is already in B, 2) b is a bid of size ≤ k in which the agent i bids higher than the price for the same items in B.</p>
<p id="15">According to the PAUSE auction, during the first stage we have only several English auctions, with the bidders submitting bids on individual items. In this case, an agent"s dominant strategy is to bid higher than the current winning bid until it reaches its valuation for that particular item. Our algorithms focus on the subsequent stages: k &gt; 1. When k &gt; 1, agents have to find g∗ i . This can be done by performing a complete search on B. However, this approach is computationally expensive since it produces a large search tree. Our algorithms represent alternative approaches to overcome this expensive search.</p>
<p id="16">In the pausebid algorithm (shown in Figure 1) we implement some heuristics to prune the search tree. Given that bidders want to maximize their utility and that at any given point there are likely only a few bids within B which The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 695 pausebid(i, k)</p>
<p id="17">= i or vi(bitems ) &gt; bvalue</p>
<p id="18">+new Bid(bitems , i, vi(bitems ))</p>
<p id="19">vi(S) &gt; 0 and ¬∃b∈Bbitems = S</p>
<p id="20">← ∅ £ Global variable</p>
<p id="21">← ui(W)£ Global variable</p>
<p id="22">− B(bitems )</p>
<p id="23">) − u∗</p>
<p id="24">| bagent = i</p>
<p id="25">← B(bitems )</p>
<p id="26">← B(bitems ) + my-payment ·bvalue −B(bitems ) surplus</p>
<p id="27">Figure 1: The pausebid algorithm which implements a branch and bound search. i is the agent and k is the current stage of the auction, for k ≥ 2. the agent can dominate, we start by defining my-bids to be the list of bids for which the agent"s valuation is higher than the current best bid, as given in B. We set the value of these bids to be the agent"s true valuation (but we won"t necessarily be bidding true valuation, as we explain later).</p>
<p id="28">Similarly, we set their-bids to be the rest of the bids from B.</p>
<p id="29">Finally, the agent"s search list is simply the concatenation of my-bids and their-bids. Note that the agent"s own bids are placed first on the search list as this will enable us to do more pruning (pausebid lines 3 to 9). The agent can now perform a branch and bound search on the branch-on-bids tree produced by these bids. This branch and bound search is implemented by pbsearch (Figure 2). Our algorithm not only implements the standard bound but it also implements other pruning techniques in order to further reduce the size of the search tree.</p>
<p id="30">The bound we use is the maximum utility that the agent can expect to receive from a given set of bids. We call it u∗ .</p>
<p id="31">Initially, u∗ is set to ui(W) (pausebid line 11) since that is the utility the agent currently receives and any solution he proposes should give him more utility. If pbsearch ever comes across a partial solution where the maximum utility the agent can expect to receive is less than u∗ then that subtree is pruned (pbsearch line 21). Note that we can determine the maximum utility only after the algorithm has searched over all of the agent"s own bids (which are first on the list) because after that we know that the solution will not include any more bids where the agent is the winner thus the agent"s utility will no longer increase. For example, pbsearch(bids, g)</p>
<p id="32">b∈g | bagent=i B(bitems ))</p>
<p id="33">← g</p>
<p id="34">← max-utility</p>
<p id="35">= i</p>
<p id="36">−(r(g) − ri(g)) − h(¯Ig)</p>
<p id="37">xitems ∩ bitems = ∅}, g) £ b is In</p>
<p id="38">xitems ∩ bitems = ∅}, g) £ b is In</p>
<p id="39">Figure 2: The pbsearch recursive procedure where bids is the set of available bids and g is the current partial solution. if an agent has only one bid in my-bids then the maximum utility he can expect is equal to his value for the items in that bid minus the minimum possible payment we can make for those items and still come up with a set of bids that has revenue greater than r(W). The calculation of the minimum payment is shown in line 19 for the partial solution case and line 9 for the case where we have a complete solution in pbsearch. Note that in order to calculate the min-payment for the partial solution case we need an upper bound on the payments that we must make for each item. This upper bound is provided by h(S) = s∈S max b∈B | s∈bitems bvalue size(bitems) . (4) This function produces a bound identical to the one used by the Bidtree algorithm-it merely assigns to each individual item in S a value equal to the maximum bid in B divided by the number of items in that bid.</p>
<p id="40">To prune the branches that cannot lead to a solution with revenue greater than the current W, the algorithm considers both the values of the bids in B and the valuations of the</p>
<p id="41">agent. Similarly to (4) we define hi(S, k) = s∈S max S | size(S )≤k and s∈S and vi(S )&gt;0 vi(S ) size(S ) (5) which assigns to each individual item s in S the maximum value produced by the valuation of S divided by the size of S , where S is a set for which the agent has a valuation greater than zero, contains s, and its size is less or equal than k. The algorithm uses the heuristics h and hi (lines 15 and 19 of pbsearch), to prune the just mentioned branches in the same way an A∗ algorithm uses its heuristic. A final pruning technique implemented by the algorithm is ignoring any branches where the agent has no bids in the current answer g and no more of the agent"s bids are in the list (pbsearch lines 6 and 7).</p>
<p id="42">The resulting g∗ found by pbsearch is thus the set of bids that has revenue bigger than r(W) and maximizes agent i"s utility. However, agent i"s bids in g∗ are still set to his own valuation and not to the lowest possible price. Lines 17 to 20 in pausebid are responsible for setting the agent"s payments so that it can achieve its maximum utility u∗ . If the agent has only one bid in g∗ then it is simply a matter of reducing the payment of that bid by u∗ from the current maximum of the agent"s true valuation. However, if the agent has more than one bid then we face the problem of how to distribute the agent"s payments among these bids. There are many ways of distributing the payments and there does not appear to be a dominant strategy for performing this distribution.</p>
<p id="43">We have chosen to distribute the payments in proportion to the agent"s true valuation for each set of items. pausebid assumes that the set of best bids B and the current best winning bidset W remains constant during its execution, and it returns the agent"s myopic utility-maximizing bidset (if there is one) using a branch and bound search.</p>
<p id="44">However it repeats the whole search at every stage. We can minimize this problem by caching the result of previous searches.</p>
<p id="45">The cachedpausebid algorithm (shown in Figure 3) is our second approach to solve the bidding problem in the PAUSE auction. It is based in a cache table called C-Table where we store some solutions to avoid doing a complete search every time. The problem is the same; the agent i has to find g∗ i . We note that g∗ i is a bidset that contains at least one bid of the agent i. Let S be a set of items for which the agent i has a valuation such that vi(S) ≥ B(S) &gt; 0, let gS i be a bidset over S such that r(gS i ) ≥ r(W) + and gS i = arg max g⊆2B ui(g), (6) where each g is a set of bids that covers all items and ∀b∈g (b ∈ B) or (bagent = i and bvalue &gt; B(bitems )) and (∃b∈gbitems = S and bagent = i). That is, gS i is i"s best bidset for all items which includes a bid from i for all S items.</p>
<p id="46">In the PAUSE auction we cannot bid for sets of items with size greater than k. So, if we have for each set of items S for which vi(S) &gt; 0 and size(S) ≤ k its corresponding gS i then g∗ i is the gS i that maximizes the agent"s utility. That is g∗ i = arg max {S | vi(S)&gt;0∧size(S)≤k} ui(gS i ). (7) Each agent i implements a hash table C-Table such that C-Table[S] = gS for all S which vi(S) ≥ B(S) &gt; 0. We can cachedpausebid(i, k, k-changed)</p>
<p id="47">← ∅</p>
<p id="48">← ui(W)</p>
<p id="49">← C-Table[S] £ Global variable</p>
<p id="50">))</p>
<p id="51">← r(gS ) − min-payment £ Global variable</p>
<p id="52">or (∃b∈B bitems ⊆ ¯S and bagent = i)</p>
<p id="53">⊆ ¯S}</p>
<p id="54">+{b ∈ B|bitems ⊆ ¯S and b /∈ B }</p>
<p id="55">) &gt; bvalue</p>
<p id="56">← i</p>
<p id="57">← vi(bitems )</p>
<p id="58">← 0</p>
<p id="59">&gt; u∗ and r(gS ) ≥ r(W) +</p>
<p id="60">b∈gS | bagent=i bvalue − B(bitems )</p>
<p id="61">) − ui(gS )</p>
<p id="62">| bagent = i</p>
<p id="63">← B(bitems )</p>
<p id="64">← B(bitems )+ my-payment ·bvalue −B(bitems ) surplus</p>
<p id="65">← ui(gS )</p>
<p id="66">← gS</p>
<p id="67">≤ 0 and vi(S) &lt; B(S)</p>
<p id="68">Figure 3: The cachedpausebid algorithm that implements a caching based search to find a bidset that maximizes the utility for the agent i. k is the current stage of the auction (for k ≥ 2), and k-changed is a boolean that is true right after the auction moved to the next stage.</p>
<p id="69">The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 697 cpbsearch(bids, g, n)</p>
<p id="70">b∈g | bagent=i B(bitems ))</p>
<p id="71">← g</p>
<p id="72">← max-utility</p>
<p id="73">= i</p>
<p id="74">−(r(g) − ri(g)) − h(¯Ig)</p>
<p id="75">xitems ∩ bitems = ∅}, g, n + 1) £ b is In</p>
<p id="76">xitems ∩ bitems = ∅}, g, n + 1) £ b is In</p>
<p id="77">Figure 4: The cpbsearch recursive procedure where bids is the set of available bids, g is the current partial solution and n is a value that indicates how deep in the list bids the algorithm has to search. then find g∗ by searching for the gS , stored in C-Table[S], that maximizes the agent"s utility, considering only the set of items S with size(S) ≤ k. The problem remains in maintaining the C-Table updated and avoiding to search every gS every time. cachedpausebid deals with this and other details.</p>
<p id="78">Let B be the set of bids that contains the new best bids, that is, B contains the bids recently added to B and the bids that have changed price (always higher), bidder, or both and were already in B. Let ¯S = Items − S be the complement of S (the set of items not included in S). cachedpausebid takes three parameters: i the agent, k the current stage of the auction, and k-changed a boolean that is true right after the auction moved to the next stage. Initially C-Table has one row or entry for each set S for which vi(S) &gt; 0. We start by eliminating the entries corresponding to each set S for which vi(S) &lt; B(S) from C-Table (line 3). Then, in the case that k-changed is true, for each set S with size(S) = k, we add to B a bid for that set with value equal to vi(S) and bidder agent i (line 5); this a bid that the agent is now allowed to consider. We then search for g∗ amongst the gS stored in C-Table, for this we only need to consider the sets with size(S) ≤ k (line 8). But how do we know that the gS in C-Table[S] is still the best solution for S? There are only two cases when we are not sure about that and we need to do a search to update C-Table[S]. These cases are: i) When k-changed is true and size(S) ≤ k, since there was no gS stored in C-Table for this S. ii) When there exists at least one bid in B for the set of items ¯S or a subset of it submitted by an agent different than i, since it is probable that this new bid can produce a solution better than the one stored in C-Table[S].</p>
<p id="79">We handle the two cases mentioned above in lines 13 to 26 of cachedpausebid. In both of these cases, since gS must contain a bid for S we need to find a bidset that cover the missing items, that is ¯S. Thus, our search space consists of all the bids on B for the set of items ¯S or for a subset of it. We build the list bids that contains only those bids.</p>
<p id="80">However, we put the bids from B at the beginning of bids (line 14) since they are the ones that have changed. Then, we replace the bids in bids that have a price lower than the valuation the agent i has for those same items with a bid from agent i for those items and value equal to the agent"s valuation (lines 16-19).</p>
<p id="81">The recursive procedure cpbsearch, called in line 25 of cachedpausebid and shown in Figure 4, is the one that finds the new gS . cpbsearch is a slightly modified version of our branch and bound search implemented in pbsearch.</p>
<p id="82">The first modification is that it has a third parameter n that indicates how deep on the list bids we want to search, since it stops searching when n less or equal to zero and not only when the list bids is empty (line 1). Each time that there is a recursive call of cpbsearch n is decreased by one when a bid from bids is discarded or out (lines 12, 15, 21, and 24) and n remains the same otherwise (lines 20 and 23). We set the value of n before calling cpbsearch, to be the size of the list bids (cachedpausebid line 21) in case i), since we want cpbsearch to search over all bids; and we set n to be the number of bids from B included in bids (cachedpausebid line 23) in case ii), since we know that only the those first n bids in bids changed and can affect our current gS .</p>
<p id="83">Another difference with pbsearch is that the bound in cpbsearch is uS which we set to be 0 (cachedpausebid line 22) when in case i) and r(gS )−min-payment (cachedpausebid line 12) when in case ii). We call cpbsearch with g already containing a bid for S. After cpbsearch is executed we are sure that we have the right gS , so we store it in the corresponding C-Table[S] (cachedpausebid line 26).</p>
<p id="84">When we reach line 27 in cachedpausebid, we are sure that we have the right gS . However, agent i"s bids in gS are still set to his own valuation and not to the lowest possible price. If uS is greater than the current u∗ , lines 31 to 34 in cachedpausebid are responsible for setting the agent"s payments so that it can achieve its maximum utility uS .</p>
<p id="85">As in pausebid, we have chosen to distribute the payments in proportion to the agent"s true valuation for each set of items. In the case that uS less than or equal to zero and the valuation that the agent i has for the set of items S is lower than the current value of the bid in B for the same set of items, we remove the corresponding C-Table[S] since we know that is not worthwhile to keep it in the cache table (cachedpausebid line 38).</p>
<p id="86">The cachedpausebid function is called when k &gt; 1 and returns the agent"s myopic utility-maximizing bidset, if there is one. It assumes that W and B remains constant during its execution.</p>
<p id="87">generatevalues(i, items)</p>
<p id="88">Figure 5: Algorithm for the generation of random value functions. expd(x) returns a random number taken from an exponential distribution with mean 1/x. 0 20 40 60 80 100</p>
<p id="89">Number of Items CachedPauseBid</p>
<p id="90">3 3 PauseBid + + + + + + + + + + Figure 6: Average percentage of convergence (y-axis), which is the percentage of times that our algorithms converge to the revenue-maximizing solution, as function of the number of items in the auction.</p>
<p id="91">We have implemented both algorithms and performed a series of experiments in order to determine how their solution compares to the revenue-maximizing solution and how their times compare with each other. In order to do our tests we had to generate value functions for the agents1 .</p>
<p id="92">The algorithm we used is shown in Figure 5. The type of valuations it generates correspond to domains where a set of agents must perform a set of tasks but there are cost savings for particular agents if they can bundle together certain subsets of tasks. For example, imagine a set of robots which must pick up and deliver items to different locations. Since each robot is at a different location and has different abilities, each one will have different preferences over how to bundle. Their costs for the item bundles are subadditive, which means that their preferences are superadditive. The first experiment we performed simply ensured the proper 1 Note that we could not use CATS [6] because it generates sets of bids for an indeterminate number of agents. It is as if you were told the set of bids placed in a combinatorial auction but not who placed each bid or even how many people placed bids, and then asked to determine the value function of every participant in the auction. 0 20 40 60 80 100</p>
<p id="93">Number of Items CachedPauseBid 3 3</p>
<p id="94">3 PauseBid + + + + + + + + + + Figure 7: Average percentage of revenue from our algorithms relative to maximum revenue (y-axis) as function of the number of items in the auction. functioning of our algorithms. We then compared the solutions found by both of them to the revenue-maximizing solution as found by CASS when given a set of bids that corresponds to the agents" true valuation. That is, for each agent i and each set of items S for which vi(S) &gt; 0 we generated a bid. This set of bids was fed to CASS which implements a centralized winner determination algorithm to find the solution which maximizes revenue. Note, however, that the revenue from the PAUSE auction on all the auctions is always smaller than the revenue of the revenue-maximizing solution when the agents bid their true valuations. Since PAUSE uses English auctions the final prices (roughly) represent the second-highest valuation, plus , for that set of items.</p>
<p id="95">We fixed the number of agents to be 5 and we experimented with different number of items, namely from 2 to</p>
<p id="96">combination. When we compared the solutions of our algorithms to the revenue-maximizing solution, we realized that they do not always find the same distribution of items as the revenue-maximizing solution (as shown in Figure 6). The cases where our algorithms failed to arrive at the distribution of the revenue-maximizing solution are those where there was a large gap between the first and second valuation for a set (or sets) of items. If the revenue-maximizing solution contains the bid (or bids) using these higher valuation then it is impossible for the PAUSE auction to find this solution because that bid (those bids) is never placed. For example, if agent i has vi(1) = 1000 and the second highest valuation for (1) is only 10 then i only needs to place a bid of 11 in order to win that item. If the revenue-maximizing solution requires that 1 be sold for 1000 then that solution will never be found because that bid will never be placed.</p>
<p id="97">We also found that average percentage of times that our algorithms converges to the revenue-maximizing solution decreases as the number of items increases. For 2 items is almost 100% but decreases a little bit less than 1 percent as the items increase, so that this average percentage of convergence is around 90% for 10 items. In a few instances our algorithms find different solutions this is due to the different The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 699 1 10 100 1000 10000</p>
<p id="98">Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 8: Average number of expanded nodes (y-axis) as function of items in the auction. ordering of the bids in the bids list which makes them search in different order.</p>
<p id="99">We know that the revenue generated by the PAUSE auction is generally lower than the revenue of the revenuemaximizing solution, but how much lower? To answer this question we calculated percentage representing the proportion of the revenue given by our algorithms relative to the revenue given by CASS. We found that the percentage of revenue of our algorithms increases in average 2.7% as the number of items increases, as shown in Figure 7. However, we found that cachedpausebid generates a higher revenue than pausebid (4.3% higher in average) except for auctions with 2 items where both have about the same percentage.</p>
<p id="100">Again, this difference is produced by the order of the search.</p>
<p id="101">In the case of 2 items both algorithms produce in average a revenue proportion of 67.4%, while in the other extreme (10 items), cachedpausebid produced in average a revenue proportion of 91.5% while pausebid produced in average a revenue proportion of 87.7%.</p>
<p id="102">The scalability of our algorithms can be determined by counting the number of nodes expanded in the search tree.</p>
<p id="103">For this we count the number of times that pbsearch gets invoked for each time that pausebid is called and the number of times that fastpausebidsearch gets invoked for each time that cachedpausebid, respectively for each of our algorithms. As expected since this is an NP-Hard problem, the number of expanded nodes does grow exponentially with the number of items (as shown in Figure 8). However, we found that cachedpausebid outperforms pausebid, since it expands in average less than half the number of nodes.</p>
<p id="104">For example, the average number of nodes expanded when</p>
<p id="105">2; and in the other extreme (10 items) cachedpausebid expands in average only 633 nodes while pausebid expands in average 1672 nodes, a difference of more than 1000 nodes.</p>
<p id="106">Although the number of nodes expanded by our algorithms increases as function of the number of items, the actual number of nodes is a much smaller than the worst-case scenario of nn where n is the number of items. For example, for 10 items we expand slightly more than 103 nodes for the case of pausebid and less than that for the case of cachedpause0.1 1 10 100 1000</p>
<p id="107">Number of Items CachedPauseBid 3 3 3 3 3 3 3 3 3 3 PauseBid + + + + + + + + + + Figure 9: Average time in seconds that takes to finish an auction (y-axis) as function of the number of items in the auction. bid which are much smaller numbers than 1010 . Notice also that our value generation algorithm (Figure 5) generates a number of bids that is exponential on the number of items, as might be expected in many situations. As such, these results do not support the conclusion that time grows exponentially with the number of items when the number of bids is independent of the number of items. We expect that both algorithms will grow exponentially as a function the number of bids, but stay roughly constant as the number of items grows.</p>
<p id="108">We wanted to make sure that less expanded nodes does indeed correspond to faster execution, especially since our algorithms execute different operations. We thus ran the same experiment with all the agents in the same machine, an Intel Centrino 2.0 GHz laptop PC with 1 GB of RAM and a 7200 RMP 60 GB hard drive, and calculated the average time that takes to finish an auction for each algorithm. As shown in Figure 9, cachedpausebid is faster than pausebid, the difference in execution speed is even more clear as the number of items increases.</p>
<p id="109">A lot of research has been done on various aspects of combinatorial auctions. We recommend [2] for a good review.</p>
<p id="110">However, the study of distributed winner determination algorithms for combinatorial auctions is still relatively new.</p>
<p id="111">One approach is given by the algorithms for distributing the winner determination problem in combinatorial auctions presented in [7], but these algorithms assume the computational entities are the items being sold and thus end up with a different type of distribution. The VSA algorithm [3] is another way of performing distributed winner determination in combinatorial auction but it assumes the bids themselves perform the computation. This algorithm also fails to converge to a solution for most cases. In [9] the authors present a distributed mechanism for calculating VCG payments in a mechanism design problem. Their mechanism roughly amounts to having each agent calculate the payments for two other agents and give these to a secure</p>
<p id="112">central server which then checks to make sure results from all pairs agree, otherwise a re-calculation is ordered. This general idea, which they call the redundancy principle, could also be applied to our problem but it requires the existence of a secure center agent that everyone trusts. Another interesting approach is given in [8] where the bidding agents prioritize their bids, thus reducing the set of bids that the centralized winner determination algorithm must consider, making that problem easier. Finally, in the computation procuring clock auction [1] the agents are given an everincreasing percentage of the surplus achieved by their proposed solution over the current best. As such, it assumes the agents are impartial computational entities, not the set of possible buyers as assumed by the PAUSE auction.</p>
<p id="113">We believe that distributed solutions to the winner determination problem should be studied as they offer a better fit for some applications as when, for example, agents do not want to reveal their valuations to the auctioneer or when we wish to distribute the computational load among the bidders. The PAUSE auction is one of a few approaches to decentralize the winner determination problem in combinatorial auctions. With this auction, we can even envision completely eliminating the auctioneer and, instead, have every agent performe the task of the auctioneer. However, while PAUSE establishes the rules the bidders must obey, it does not tell us how the bidders should calculate their bids.</p>
<p id="114">We have presented two algorithms, pausebid and cachedpausebid, that bidder agents can use to engage in a PAUSE auction. Both algorithms implement a myopic utility maximizing strategy that is guaranteed to find the bidset that maximizes the agent"s utility given the set of outstanding best bids at any given time, without considering possible future bids. Both algorithms find, most of the time, the same distribution of items as the revenue-maximizing solution. The cases where our algorithms failed to arrive at that distribution are those where there was a large gap between the first and second valuation for a set (or sets) of items.</p>
<p id="115">As it is an NP-Hard problem, the running time of our algorithms remains exponential but it is significantly better than a full search. pausebid performs a branch and bound search completely from scratch each time it is invoked. cachedpausebid caches partial solutions and performs a branch and bound search only on the few portions affected by the changes on the bids between consecutive times. cachedpausebid has a better performance since it explores fewer nodes (less than half) and it is faster. As expected the revenue generated by a PAUSE auction is lower than the revenue of a revenue-maximizing solution found by a centralized winner determination algorithm, however we found that cachedpausebid generates in average 4.7% higher revenue than pausebid. We also found that the revenue generated by our algorithms increases as function of the number of items in the auction.</p>
<p id="116">Our algorithms have shown that it is feasible to implement the complex coordination constraints supported by combinatorial auctions without having to resort to a centralized winner determination algorithm. Moreover, because of the design of the PAUSE auction, the agents in the auction also have an incentive to perform the required computation. Our bidding algorithms can be used by any multiagent system that would use combinatorial auctions for coordination but would rather not implement a centralized auctioneer.</p>
<p id="117">[1] P. J. Brewer. Decentralized computation procurement and computational robustness in a smart market.</p>
<p id="118">Economic Theory, 13(1):41-92, January 1999. [2] P. Cramton, Y. Shoham, and R. Steinberg, editors.</p>
<p id="119">Combinatorial Auctions. MIT Press, 2006. [3] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.</p>
<p id="120">Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches. In Proceedings of the Sixteenth International Joint Conference on Artificial Intelligence, pages 548-553. Morgan Kaufmann Publishers Inc., 1999. [4] F. Kelly and R. Stenberg. A combinatorial auction with multiple winners for universal service.</p>
<p id="121">Management Science, 46(4):586-596, 2000. [5] A. Land, S. Powell, and R. Steinberg. PAUSE: A computationally tractable combinatorial auction. In Cramton et al. [2], chapter 6, pages 139-157. [6] K. Leyton-Brown, M. Pearson, and Y. Shoham.</p>
<p id="122">Towards a universal test suite for combinatorial auction algorithms. In Proceedings of the 2nd ACM conference on Electronic commerce, pages 66-76.</p>
<p id="123">ACM Press, 2000. http://cats.stanford.edu. [7] M. V. Narumanchi and J. M. Vidal. Algorithms for distributed winner determination in combinatorial auctions. In LNAI volume of AMEC/TADA. Springer,</p>
<p id="124">[8] S. Park and M. H. Rothkopf. Auctions with endogenously determined allowable combinations.</p>
<p id="125">Technical report, Rutgets Center for Operations Research, January 2001. RRR 3-2001. [9] D. C. Parkes and J. Shneidman. Distributed implementations of vickrey-clarke-groves auctions. In Proceedings of the Third International Joint Conference on Autonomous Agents and MultiAgent Systems, pages 261-268. ACM, 2004. [10] M. H. Rothkopf, A. Pekec, and R. M. Harstad.</p>
<p id="126">Computationally manageable combinational auctions.</p>
<p id="127">Management Science, 44(8):1131-1147, 1998. [11] T. Sandholm. An algorithm for winner determination in combinatorial auctions. Artificial Intelligence, 135(1-2):1-54, February 2002. [12] T. Sandholm, S. Suri, A. Gilpin, and D. Levine.</p>
<p id="128">CABOB: a fast optimal algorithm for winner determination in combinatorial auctions. Management Science, 51(3):374-391, 2005.</p>
</body>
</document>
