/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package services.complexity.rhythm.views;

import data.Block;
import data.Sentence;
import data.Word;
import data.cscl.Conversation;
import data.cscl.Participant;
import java.awt.Color;
import java.awt.Font;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.stream.Collectors;
import javax.swing.JFrame;
import javax.swing.table.DefaultTableModel;
import services.complexity.rhythm.models.ParticipantModel;
import services.complexity.rhythm.tools.RhythmTool;

/**
 *
 * @author valentin.sergiu.cioaca@gmail.com
 */
public class ConversationRhythmView extends javax.swing.JFrame {
    private final Conversation chat;
    private DefaultTableModel modelContent;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    
    private static final int MIN_NO_CONTRIBUTIONS = 3;
    private static final int MIN_NO_CONTENT_WORDS = 50;
    
    private Map<String, Integer> noContributions;
    private Map<String, Integer> rhythmicIndices;
    private Map<String, Double> freqOfRhythmicIds;
    private Map<String, Integer> rhythmicDiameters;
    private Map<String, Double> rhythmicCoeff;
    
    @SuppressWarnings("OverridableMethodCallInConstructor")
    public ConversationRhythmView(Conversation chat) {
        super("ReaderBench - Rhythm Analysis");
	setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        getContentPane().setBackground(Color.WHITE);
        this.chat = chat;
        
        setBounds(50, 50, 1180, 710);
        
        initComponents();
        processConversation();
        updateContent();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();

//        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        
        modelContent = new ParticipantModel();
        jTable1.setModel(modelContent);
        jScrollPane1.setViewportView(jTable1);
        jTable1.setFillsViewportHeight(true);


        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, "Rhythmic features");
        jLabel1.setFont(new Font("SansSerif", Font.BOLD, 12));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 608, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(44, 44, 44)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(81, Short.MAX_VALUE))
        );

        pack();
    }
    
    private void updateContent() {
        DecimalFormat df = new DecimalFormat("#.##");
        for (Map.Entry<String, Integer> entry : noContributions.entrySet()) {
            String p = entry.getKey();
            Object[] row = {p, entry.getValue(),
                rhythmicIndices.get(p),
                df.format(freqOfRhythmicIds.get(p)),
                rhythmicDiameters.get(p),
                df.format(rhythmicCoeff.get(p))};
            modelContent.addRow(row);
        }
    }
    
    private void processConversation() {
        noContributions = new TreeMap<>();
        rhythmicIndices = new TreeMap<>();
        freqOfRhythmicIds = new TreeMap<>();
        rhythmicDiameters = new TreeMap<>();
        rhythmicCoeff = new TreeMap<>();
        Map<String, List<Integer>> valuesForRhythmicIndices = new HashMap<>(); 
        
        for (Participant p : chat.getParticipants()) {
            int noContentWords = 0;
            for (Block b : p.getSignificantContributions().getBlocks()) {
                if (b != null) {
                    for (Map.Entry<Word, Integer> entry : b.getWordOccurences().entrySet()) {
                        noContentWords += entry.getValue();
                    }
                }
            }
            if (p.getSignificantContributions().getBlocks().size() >= MIN_NO_CONTRIBUTIONS && noContentWords >= MIN_NO_CONTENT_WORDS) {
                noContributions.put(p.getName(), p.getSignificantContributions().getBlocks().size());
                valuesForRhythmicIndices.put(p.getName(), new ArrayList<>());
                int infRhythmicLimit = Integer.MAX_VALUE, supRhythmicLimit = 0;
                int deviations = 0;
                Map<Integer, Integer> cntSyllabicStructures = new TreeMap<>();
                rhythmicDiameters.put(p.getName(), 0);
                for (Block b : p.getSignificantContributions().getBlocks()) {
                    if (b == null) {
                        continue;
                    }
                    for (Sentence s : b.getSentences()) {
                        List<Word> unit = s.getAllWords();
                        // get rhythmic structure SM aproach
                        List<Integer> rhythmicStructure = RhythmTool.getRhythmicStructureSM(unit);
                        // calculate rhythmic index
                        int unitRhythmicIndex = RhythmTool.calcRhythmicIndexSM(unit.size(), rhythmicStructure.size());
                        if (unitRhythmicIndex != RhythmTool.UNDEFINED) {
                            valuesForRhythmicIndices.get(p.getName()).add(unitRhythmicIndex);
                        }
                        if (!rhythmicStructure.isEmpty()) {
                            // update language rhythmic diameter
                            int min = Collections.min(rhythmicStructure);
                            int max = Collections.max(rhythmicStructure);
                            infRhythmicLimit = Math.min(infRhythmicLimit, min);
                            supRhythmicLimit = Math.max(supRhythmicLimit, max);
                            rhythmicDiameters.put(p.getName(), Math.max(rhythmicDiameters.get(p.getName()), max - min));
                        }
                        String[] newRhythmicUnits = s.getText().split("[\\p{Punct}]+");
                        for (String newUnit : newRhythmicUnits) {
                            List<String> unitList = Arrays.asList(newUnit.trim().split("\\s+"));
                            List<Integer> repr = RhythmTool.testNewUnitDefinition(unitList);
                            if (!repr.isEmpty()) {
                                // populate map with syllabic structures and their number of appearences
                                for (Integer nr : repr) {
                                    if (nr == 0) continue;
                                    cntSyllabicStructures.put(nr,
                                    cntSyllabicStructures.containsKey(nr) ? cntSyllabicStructures.get(nr)+1 : 1);
                                }
                                // calculate number of deviations
                                deviations += RhythmTool.calcDeviations(repr);
                            }
                        }
                    }
                }
                // calculate rhythmic coefficient
                int tonicNumber = cntSyllabicStructures.values().stream().reduce(0, Integer::sum);
                int dominantInd = RhythmTool.getDominantIndex(cntSyllabicStructures.values().stream()
                        .collect(Collectors.toList()));
                int keyOfMaxVal = cntSyllabicStructures.keySet().stream()
                        .collect(Collectors.toList()).get(dominantInd);
                int sum = cntSyllabicStructures.get(keyOfMaxVal);
                sum += (cntSyllabicStructures.containsKey(keyOfMaxVal-1)) ? cntSyllabicStructures.get(keyOfMaxVal-1) : 0;
                sum += (cntSyllabicStructures.containsKey(keyOfMaxVal+1)) ? cntSyllabicStructures.get(keyOfMaxVal+1) : 0;
                rhythmicCoeff.put(p.getName(), 1.0 * (deviations + tonicNumber - sum) / tonicNumber);
            }
        }
        for (Map.Entry<String, List<Integer>> entry : valuesForRhythmicIndices.entrySet()) {
            int maxInd = Collections.max(entry.getValue());
            rhythmicIndices.put(entry.getKey(), maxInd);
            freqOfRhythmicIds.put(entry.getKey(), 
                    1.0 * Collections.frequency(entry.getValue(), maxInd) / entry.getValue().size());
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ConversationRhythmView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ConversationRhythmView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ConversationRhythmView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ConversationRhythmView.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ConversationRhythmView(null).setVisible(true);
            }
        });
    }
}
